const TruffleAssert=require("truffle-assertions"),Ethers=require("ethers"),Helpers=require("../helpers"),BridgeContract=artifacts.require("Bridge"),ERC20MintableContract=artifacts.require("ERC20PresetMinterPauser"),ERC20HandlerContract=artifacts.require("ERC20Handler"),GenericHandlerContract=artifacts.require("GenericHandler"),CentrifugeAssetContract=artifacts.require("CentrifugeAsset");contract("Bridge - [admin]",async accounts=>{const domainID=1,initialRelayers=accounts.slice(0,3),initialRelayerThreshold=2,expectedBridgeAdmin=accounts[0],someAddress="0xcafecafecafecafecafecafecafecafecafecafe",bytes32="0x0";let ADMIN_ROLE,RESOURCE_SETTER_ROLE,BridgeInstance,withdrawData="";const assertOnlyAdmin=(method,...params)=>TruffleAssert.reverts(method(...params,{from:initialRelayers[1]}),"sender doesn't have admin role");beforeEach(async()=>{BridgeInstance=await BridgeContract.new(1,initialRelayers,2,100),ADMIN_ROLE=await BridgeInstance.DEFAULT_ADMIN_ROLE(),RESOURCE_SETTER_ROLE=await BridgeInstance.RESOURCE_SETTER_ROLE()}),it("Bridge should not be paused",async()=>{assert.isFalse(await BridgeInstance.paused())}),it("Bridge should be paused",async()=>{await TruffleAssert.passes(BridgeInstance.adminPauseTransfers()),assert.isTrue(await BridgeInstance.paused())}),it("Bridge should be unpaused after being paused",async()=>{await TruffleAssert.passes(BridgeInstance.adminPauseTransfers()),assert.isTrue(await BridgeInstance.paused()),await TruffleAssert.passes(BridgeInstance.adminUnpauseTransfers()),assert.isFalse(await BridgeInstance.paused())}),it("_relayerThreshold should be initialRelayerThreshold",async()=>{assert.equal(await BridgeInstance._relayerThreshold.call(),2)}),it("_relayerThreshold should be initialRelayerThreshold",async()=>{const newRelayerThreshold=1;await TruffleAssert.passes(BridgeInstance.adminChangeRelayerThreshold(1)),assert.equal(await BridgeInstance._relayerThreshold.call(),1)}),it("newRelayer should be added as a relayer",async()=>{const newRelayer=accounts[4];await TruffleAssert.passes(BridgeInstance.adminAddRelayer(newRelayer)),assert.isTrue(await BridgeInstance.isRelayer(newRelayer))}),it("newRelayer should be removed as a relayer after being added",async()=>{const newRelayer=accounts[4];await TruffleAssert.passes(BridgeInstance.adminAddRelayer(newRelayer)),assert.isTrue(await BridgeInstance.isRelayer(newRelayer)),await TruffleAssert.passes(BridgeInstance.adminRemoveRelayer(newRelayer)),assert.isFalse(await BridgeInstance.isRelayer(newRelayer))}),it("existingRelayer should not be able to be added as a relayer",async()=>{const existingRelayer=accounts[1];await TruffleAssert.reverts(BridgeInstance.adminAddRelayer(existingRelayer)),assert.isTrue(await BridgeInstance.isRelayer(existingRelayer))}),it("nonRelayerAddr should not be able to be added as a relayer",async()=>{const nonRelayerAddr=accounts[4];await TruffleAssert.reverts(BridgeInstance.adminRemoveRelayer(nonRelayerAddr)),assert.isFalse(await BridgeInstance.isRelayer(nonRelayerAddr))}),it("Bridge admin should be expectedBridgeAdmin",async()=>{assert.isTrue(await BridgeInstance.hasRole(ADMIN_ROLE,expectedBridgeAdmin))}),it("Bridge admin should be changed to expectedBridgeAdmin",async()=>{const expectedBridgeAdmin2=accounts[1];await TruffleAssert.passes(BridgeInstance.renounceAdmin(expectedBridgeAdmin2)),assert.isTrue(await BridgeInstance.hasRole(ADMIN_ROLE,expectedBridgeAdmin2))}),it("Should set a Resource ID for handler address",async()=>{const ERC20MintableInstance=await ERC20MintableContract.new("token","TOK"),resourceID=Helpers.createResourceID(ERC20MintableInstance.address,1),ERC20HandlerInstance=await ERC20HandlerContract.new(BridgeInstance.address);await BridgeInstance.grantRole(RESOURCE_SETTER_ROLE,!0),assert.equal(await BridgeInstance._resourceIDToHandlerAddress.call(resourceID),Ethers.constants.AddressZero),await TruffleAssert.passes(BridgeInstance.adminSetResource(ERC20HandlerInstance.address,resourceID,ERC20MintableInstance.address)),assert.equal(await BridgeInstance._resourceIDToHandlerAddress.call(resourceID),ERC20HandlerInstance.address)}),it("Should set a ERC20 Resource ID and contract address",async()=>{const ERC20MintableInstance=await ERC20MintableContract.new("token","TOK"),resourceID=Helpers.createResourceID(ERC20MintableInstance.address,1),ERC20HandlerInstance=await ERC20HandlerContract.new(BridgeInstance.address);await TruffleAssert.passes(BridgeInstance.adminSetResource(ERC20HandlerInstance.address,resourceID,ERC20MintableInstance.address)),assert.equal(await ERC20HandlerInstance._resourceIDToTokenContractAddress.call(resourceID),ERC20MintableInstance.address),assert.equal(await ERC20HandlerInstance._tokenContractAddressToResourceID.call(ERC20MintableInstance.address),resourceID.toLowerCase())}),it("Should require admin role to set a ERC20 Resource ID and contract address",async()=>{await assertOnlyAdmin(BridgeInstance.adminSetResource,someAddress,"0x0",someAddress)}),it("Should set a Generic Resource ID and contract address",async()=>{const CentrifugeAssetInstance=await CentrifugeAssetContract.new(),resourceID=Helpers.createResourceID(CentrifugeAssetInstance.address,1),GenericHandlerInstance=await GenericHandlerContract.new(BridgeInstance.address);await TruffleAssert.passes(BridgeInstance.adminSetGenericResource(GenericHandlerInstance.address,resourceID,CentrifugeAssetInstance.address,"0x00000000",0,"0x00000000")),assert.equal(await GenericHandlerInstance._resourceIDToContractAddress.call(resourceID),CentrifugeAssetInstance.address),assert.equal(await GenericHandlerInstance._contractAddressToResourceID.call(CentrifugeAssetInstance.address),resourceID.toLowerCase())}),it("Should require admin role to set a Generic Resource ID and contract address",async()=>{await assertOnlyAdmin(BridgeInstance.adminSetGenericResource,someAddress,"0x0",someAddress,"0x00000000",0,"0x00000000")}),it("Should set ERC20MintableInstance.address as burnable",async()=>{const ERC20MintableInstance=await ERC20MintableContract.new("token","TOK"),resourceID=Helpers.createResourceID(ERC20MintableInstance.address,1),ERC20HandlerInstance=await ERC20HandlerContract.new(BridgeInstance.address);await TruffleAssert.passes(BridgeInstance.adminSetResource(ERC20HandlerInstance.address,resourceID,ERC20MintableInstance.address)),await TruffleAssert.passes(BridgeInstance.adminSetBurnable(ERC20HandlerInstance.address,ERC20MintableInstance.address)),assert.isTrue(await ERC20HandlerInstance._burnList.call(ERC20MintableInstance.address))}),it("Should require admin role to set ERC20MintableInstance.address as burnable",async()=>{await assertOnlyAdmin(BridgeInstance.adminSetBurnable,someAddress,someAddress)}),it("Should set fee",async()=>{assert.equal(await BridgeInstance._fee.call(),0);const fee=Ethers.utils.parseEther("0.05");await BridgeInstance.adminChangeFee(fee);const newFee=await BridgeInstance._fee.call();assert.equal(web3.utils.fromWei(newFee,"ether"),"0.05")}),it("Should not set the same fee",async()=>{await TruffleAssert.reverts(BridgeInstance.adminChangeFee(0),"Current fee is equal to new fee")}),it("Should require admin role to set fee",async()=>{await assertOnlyAdmin(BridgeInstance.adminChangeFee,0)}),it("Should withdraw funds",async()=>{const numTokens=10,tokenOwner=accounts[0];let ownerBalance,handlerBalance;const ERC20MintableInstance=await ERC20MintableContract.new("token","TOK"),resourceID=Helpers.createResourceID(ERC20MintableInstance.address,1),ERC20HandlerInstance=await ERC20HandlerContract.new(BridgeInstance.address);await TruffleAssert.passes(BridgeInstance.adminSetResource(ERC20HandlerInstance.address,resourceID,ERC20MintableInstance.address)),await ERC20MintableInstance.mint(tokenOwner,10),ownerBalance=await ERC20MintableInstance.balanceOf(tokenOwner),assert.equal(ownerBalance,10),await ERC20MintableInstance.transfer(ERC20HandlerInstance.address,10),ownerBalance=await ERC20MintableInstance.balanceOf(tokenOwner),assert.equal(ownerBalance,0),handlerBalance=await ERC20MintableInstance.balanceOf(ERC20HandlerInstance.address),assert.equal(handlerBalance,10),withdrawData=Helpers.createERCWithdrawData(ERC20MintableInstance.address,tokenOwner,10),await BridgeInstance.adminWithdraw(ERC20HandlerInstance.address,withdrawData),ownerBalance=await ERC20MintableInstance.balanceOf(tokenOwner),assert.equal(ownerBalance,10)}),it("Should require admin role to withdraw funds",async()=>{await assertOnlyAdmin(BridgeInstance.adminWithdraw,someAddress,"0x0")}),it("Should set nonce",async()=>{const nonce=3;await BridgeInstance.adminSetDepositNonce(1,3);const nonceAfterSet=await BridgeInstance._depositCounts.call(1);assert.equal(nonceAfterSet,3)}),it("Should require admin role to set nonce",async()=>{await assertOnlyAdmin(BridgeInstance.adminSetDepositNonce,1,3)}),it("Should not allow for decrements of the nonce",async()=>{const currentNonce=3;await BridgeInstance.adminSetDepositNonce(1,3);const newNonce=2;await TruffleAssert.reverts(BridgeInstance.adminSetDepositNonce(1,2),"Does not allow decrements of the nonce")})});